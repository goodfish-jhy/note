# 并查集

并查集是一种简单直观的数据结构，其用于维护多个集合的成员关系，支持两种操作：

- 合并：将两个元素所属的集合进行合并。
- 查询：查询元素所属集合，这可以用于判断两元素是否在同一集合内。

并查集可以认为是一片森林，其中一个集合被视为一棵树，既同一集合的元素一定在同一棵树上。

并查集在经过修改后可以支持单个元素的删除、移动；使用动态开点线段树还可以实现可持久化并查集。

并查集常作为其他算法的一部分出现，例如最小生成树。

## 初始化

我们定义数组 $fat[i]$ 为元素 $i$ 的父亲节点；方便起见，我们定义根节点的父亲节点为它本身；

对于初始情况，所有元素彼此独立，即 $fat[i] = i$。

```cpp
const int MAXN = 1e5;

int fat[MAXN];

void init(){
    for (int i=0;i<MAXN;i++){
        fat[i] = i;
    }
    return ;
}
```

## 查询

对于两个元素查询其是否在同一集合内，其实就是查询这两个节点是否在同一棵树上。不难想到沿树向上找到根节点，再对根节点进行比对，如果根节点相同，那么这两个元素就在同一集合内。为了方便后续复用，此处`find(int i)`函数实际上是查询$i$元素所属树的根节点。

```cpp
int find(int i){
    if (fat[i] == i) return i;
    else return find(fat[i]); 
}
```

### 路径压缩优化

不难看出，在查找的过程中所经过的每一个元素其实都属于同一集合，我们可以将这些元素直接连接到根节点，从而减少树的深度，加快查询速度。

```cpp
int find(int i){
    if (fat[i] == i) return i;
    else return fat[i] = find(fat[i]); 
}
```

##  合并

对于两个元素合并其所属集合，其实就是合并$i,j$所在的树。不难想到通过将一棵树的根节点连接到另一棵树的根节点来实现。

```cpp
void unite(int i, int j){
    fat[find(i)] = find(j);
}
```

### 启发式合并

合并时，选择哪棵树的根节点作为新树的根节点会影响未来操作的复杂度。我们可以将节点较少或深度较小的树连到另一棵，以免发生退化。

## 统计树的数量

有的时候，我们可能会需要计算并查集中维护的集合的数量，等价于树的数量。在这种情况下，我们可以通过统计 $fat[i]==i$ 的元素数量来实现。

```cpp

int count(int n){
    int cnt=0;
    for (int i=0;i<n;i++)
        if (fat[i]==i) cnt++;
    return cnt;
}

```