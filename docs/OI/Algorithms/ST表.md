# ST表

## 简介

ST表（Sparse Table，稀疏表）是一种基于倍增思想的数据结构，可以做到 $\Theta(n\log n)$ 预处理，$\Theta(1)$ 回答每个询问，但是不支持修改操作。

ST表用于解决 **可重复贡献问题**，例如区间最大（最小）值和区间gcd问题。

!!!  **可重复贡献问题** 的定义
    如果一个运算 $opt$ 满足 $opt(x, x) = x$，那么这个问题就是可重复贡献的，例如：
    - 最大值: $\max(a, a) = a$
    - ​最小值: $\min(a, a) = a$
    - ​按位与: $a \& a = a$
    - ​按位或: $a | a = a$
    这意味着同一个值对运算结果贡献多次也不会影响最终结果。这是ST表能工作的基础。

## 实现

以区间最大值为例，我们来讲解一下ST表的实现内容。

根据倍增思想，我们定义 $f_{i,j}$ 为原数列中第 $i$ 位后 $2^j$ 位内的最大值。其中显然有 $f_{1,0} = a_i$ 。我们发现任意一个区间都可以由至多两个预处理出来的区间进行覆盖。

具体来说，对于一个区间 $[l, r]$ 其可以分为 $[l, l+ \log _2(r-l+1)]$ 和 $[r-2^{\lfloor  \log(r-l+1) \rfloor}, r]$

需要注意，对于这两个预处理出来的区间并不要求没有重叠部分，重叠部分根据上文中对于 **可重复贡献问题** 的定义，重复的区间并不影响答案的正确性。

\begin{align}
& \max(\boxed{\max(\{a_i, \dots,  a_{i+2^{j-1}-1}\})}\boxed{\max(\{ a_{i+2^{j-1}},\dots a_{i+2^j-1}\}\})})
\\  = &\max(\boxed{\max(\{a_i, \dots,  a_{i+2^j-1}\}})
\end{align}

综上，我们可以写出ST表初始化和查询的代码：

```cpp
typedef unsigned long long ull;

inline ull fast_log2(ull x) {return 63 - __builtin_clzll(x);}

// 初始化
int n, m;cin>>n>>m;
for (int i=0;i<n;++i) cin>>a[i][0];
for (int j=1;j<=logN;++j)
  for (int i=0;i+(1<<j)-1<n;++i)
    a[i][j] = max(a[i][j-1], a[i+(1<<(j-1))][j-1]);

// 查询
while (m--){
  int l, r;
  cin>>l>>r;
  int log_k = fast_log2(r-l+1);
  printf("%d\n", max(a[l][log_k], a[r-(1<<log_k)+1][log_k]));
}
```

一些老教材中可能会预处理log数组，但实际上，这么做不光时间更慢，而且还需要耗费大量的存储空间。在竞赛中，一般直接使用`cmath`中的`log2()`或者上述代码中的函数`ull fast_log2()`实现。

在所有实现的方法中，上述代码中的方法是最快的，上述函数通过`__builtin_clzll(x)`统计x的前导零的数量，在最终编译时只会编译为单条cpu指令，全程在寄存器内完成操作，速度甚至快于读取L1缓存。

其只能得到向下取整的结果，如果你需要浮点数运算，则不能使用该方法。

需要注意，需保证x>0，`__builtin_clzll(0)`没有定义，可能是任意值。

## 附

最后在这里丢一个区间信息维护的算法一览，以便读者对于这类题目所使用的算法的功能特性有较清晰的认识。

| 数据结构 | 支持的查询/修改（典型） | 单次复杂度（典型） | 适用/备注 | 实现难度 |
|---|---|---:|---|---|
| 树状数组（BIT） | 点改、前缀和；两棵 BIT 做区间加+区间和 | O(log n) | 仅适合可加性信息（和/计数/秩）；内存小、常数小 | 低 |
| 线段树（无懒标记） | 区间和/最值/gcd 等查询；单点修改 | O(log n) | 通用“可合并信息”；不适合区间修改 | 低-中 |
| 线段树（懒标记） | 区间加/赋值/翻转等 + 区间查询 | O(log n) | 在线区间修改首选；模板化强 | 中 |
| 吉司机线段树 | 区间 chmin/chmax/加/和/最值 | 均摊 O(log n) | 复杂约束的区间操作；卡常敏感 | 高 |
| 主席树（可持久化线段树） | 多版本点改 + 历史/当前版本查询（区间第 k/≤x 计数） | O(log n) | 离线/多版本；值域查询强 | 中-高 |
| 动态/可并线段树 | 大值域稀疏的点改/区间查；合并两棵树 | O(log U) | U 为值域；内存按需开点 | 中 |
| 2D 线段树 / 2D BIT | 矩形修改/查询（和/计数/最值） | O(log² n) | 多维数据；实现较繁琐 | 中-高 |
| 树套树（线段树套平衡树/BIT） | 区间内 ≤x 计数/第 k；点改 | O(log² n) | 顺序统计/值域统计；可扩展性强 | 高 |
| 隐式键平衡树（Treap/Splay） | split/merge；区间翻转/加/赋值/求和/最大子段和 | 均摊 O(log n) | 维护序列，支持复杂区间操作 | 中-高 |
| 重链剖分（HLD）+ 线段树/BIT | 树上路径/子树 修改与查询 | O(log² n)（可优到 O(log n)） | 图为树；路径问题首选 | 中-高 |
| LCT（Link-Cut Tree） | 动态连边/断边；路径加/和/最值 | 均摊 O(log n) | 动态树问题；实现难 | 高 |
| Wavelet Tree（小波树） | 区间第 k、≤x 计数；点更新 | O(log σ) | 值域相关顺序统计；σ 为值域 | 中 |
| 分块（根号分治） | 区间加/赋值/和/最值（块标记） | O((n/B)+B) | 常数小、实现简；取 B≈√n | 低 |
| Sparse Table（ST 表） | 静态 RMQ/GCD/Idempotent 查询 | O(1) 查询，O(n log n) 预处理 | 只查不改；不可维护修改 | 低 |
| 莫队 / 带修莫队（离线） | 大量区间统计；少量单点修改 | 约 O(q√n) / O((n+q)^{2/3}) | 离线；适合频次/可加减贡献 | 中-高 |
