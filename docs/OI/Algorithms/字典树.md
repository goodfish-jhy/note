# 字典树

## 简介

字典树（Trie）是一种用于存储字符串的树形数据结构。它可以有效地进行字符串的查找和插入操作，特别适合处理大量字符串的场景，支持两种操作：

- **插入** ：插入一个新的字符串到字典树当中。
- **查询** ：查询当前字典树内是否存在指定的字符串。

AC自动机可以视为在字典树上的kmp算法，所以字典树是AC自动机的一个前置知识。

在这里放一张图(From OI-Wiki)：

![trie1](../../assets/image/Algorithms/trie1.png)

可以发现，在字典树当中，每一条边都代表了一个字母，从根节点到叶子节点的一条路径就构成了一个字符串。

但是这张图中没有展示一个字符串是已有字符串的前缀的情况，在这种情况下，会出现一个字符串结束了，但是其结束节点并不是叶子结点，例如`car`和`cartoon`。我们可以通过在每个节点维护一个布尔类型的表示，记录是否有 **以当前节点为结尾的字符串存在** 来解决。

## 实现

### 初始化

在本文中，我们使用结构体数组进行字典树的存储，具体来说：

```cpp
const int MAXN = 1e5;

struct Node{
    int next[26];
    bool exist = false;
}trie[MAXN];
```

在这个结构体当中，我们采用一个`int next[]`数组存储节点间关系。`next[]`数组的大小由题目中的字符集大小决定（若字符集为所有小写英文字母，则字符集大小为26）；使用一个 `bool exist` 来存储是否有以该节点为结尾的字符串；

### 插入

```cpp
int eCnt = 0;

void insert(string a){
    int idx = 0;
    for (auto ch : a){
        if (! trie[idx].next[ch-'a']) trie[idx].next[ch-'a'] = ++eCnt;
        idx = trie[idx].next[ch-'a'];
    }
    trie[idx].exist = true;
}
```

我们维护一个变量 `int eCnt` 用于分配新的节点编号，从 $1$ 开始，$trie[0]$ 为父节点。

通过遍历传入的字符串，查找是否存在与当前字符串相符的边，如果不存在，则创建一个新的节点并连一条与之相符的边。

最后将结尾节点的 `exist` 属性设为 `true` 表示 **有以该节点为结尾的字符串**。
